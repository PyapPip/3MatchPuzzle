12/30
matchData에 따르면 모든 블럭이 제대로 검사되고있지 않거나, 검사하였다고 표기되지 않음.
MapManager 72의 if문은 잘못되었다.

12/31 
MapManager 72의 if문에는 문제 없었음.
if문의 문제가 아님. 블럭 위치를 바꿀때에 배열에 값이 제대로 입력되지 않아서 검사되지 않았던것.

1/5
블럭 파괴는 MapComponet에 넣어야할까 MapManager에 넣어야할까?
블럭의 isMatchChack를 사용할것인가 MapComponent의 MatchData를 사용할것인가?
당장 혼용되어 사용하는중이라 수정이 필요하다.

1/6
매치된 블럭이 아니면 파괴될 일이 없기때문에 함수화가 가능하다. 블럭 파괴 기본함수가 활용될 여지가 그렇게 많이 없기 때문에, MapManager에서
일괄적으로 처리할 수 있다.
블럭의 상태는 블럭 개인이 가지고있는 것 보다 하나의 스크립트에서 일괄적으로 관리하는것이 나을 것 같다.
블럭이 파괴된 후 내려올 수 있는 블럭들을 모아 fall 실행 -> 위치계산을 어떻게 해야할지?
블럭파괴->해당 x축의 빈자리중 가장 낮은자리가 어디인지 전달 -> 생성된 순서대로 더해 좌표 계산 후 떨어지는 속도

1/14
맵의 빈자리를 채우는 로직을 생각중.
1. 블럭을 파괴할때의 좌표 정보를 이용한다 
	1.1 블럭을 파괴하면서 해당 블럭 위의 블럭들에 내려와야하는 Y좌표 수를 저장하기
		블럭을 파괴할때에 파괴된 블럭 위에 접근, 해당 블럭의 변수에 or 해당 정보를 저장하는 2차원 배열에 값 입력
		해당하는 값 만큼 블럭의 Y좌표 떨어뜨리고 목표 위치로 설정하여 블럭들 일괄적으로 애니메이션 재생. 

		우려사항.
		블럭을 파괴하는 함수로서 해당 작업을 수행하는것이 맞는가? (직관성 저하.) 
		이를 위해 블럭 컴포넌트에 접근해 얼마나 떨어지는지 받아와야한다. (접근하지 않고도 처리할 좋은 방법이 있나?) 		

2. 매치된 블럭을 전부 파괴 후 맵을 검사하여 처리한다
	2.1 맵 검사시 빈자리 위에 블럭이 존재한다면 하나씩 내리기 -> 빈자리 위에 블럭이 존재하지 않을 때 까지 반복
		맵을 검사하여 빈자리가 있음
		빈자리 위의 블럭들을 반복하여 접근 가장 낮은 빈자리로 하나씩 옮김
			없을경우 그냥 이동

		우려사항. 	
		반복과정이 너무 많아져 직관성이 떨어지지 않는가?
		다만, 브루트포스의 구조에 익지 않은 탓에 거부감 + 이해하기 어려움 이 있는것일 수도 있음. 
		연산 자체는 성능에 영향을 줄 만큼 많이 늘어나지는 않는 것 같긴 하다

	2.2 맵 검사시 빈자리 위에 블럭들에 내려와야하는 Y좌표 수를 저장하기
		맵을 검사하며 빈자리가 발견될 경우 빈자리 위에 존재하는 블럭의 변수에 or 
		해당 정보를 저장하는 2차원 배열에 값 입력
		해당하는 값 만큼 블럭의 Y좌표 떨어뜨리고 목표 위치로 설정하여 블럭들 일괄적으로 애니메이션 재생. 

		우려사항
		이미 블럭을 파괴할때에 순회한 맵을 이 작업을 위해 한번 더 순회해야한다.
		괜히 코드가 길어져 내용을 파악하기 힘들어지지는 않는가?

