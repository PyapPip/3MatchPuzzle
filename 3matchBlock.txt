12/30
matchData에 따르면 모든 블럭이 제대로 검사되고있지 않거나, 검사하였다고 표기되지 않음.
MapManager 72의 if문은 잘못되었다.

12/31 
MapManager 72의 if문에는 문제 없었음.
if문의 문제가 아님. 블럭 위치를 바꿀때에 배열에 값이 제대로 입력되지 않아서 검사되지 않았던것.

1/5
블럭 파괴는 MapComponet에 넣어야할까 MapManager에 넣어야할까?
블럭의 isMatchChack를 사용할것인가 MapComponent의 MatchData를 사용할것인가?
당장 혼용되어 사용하는중이라 수정이 필요하다.

1/6
매치된 블럭이 아니면 파괴될 일이 없기때문에 함수화가 가능하다. 블럭 파괴 기본함수가 활용될 여지가 그렇게 많이 없기 때문에, MapManager에서
일괄적으로 처리할 수 있다.
블럭의 상태는 블럭 개인이 가지고있는 것 보다 하나의 스크립트에서 일괄적으로 관리하는것이 나을 것 같다.
블럭이 파괴된 후 내려올 수 있는 블럭들을 모아 fall 실행 -> 위치계산을 어떻게 해야할지?
블럭파괴->해당 x축의 빈자리중 가장 낮은자리가 어디인지 전달 -> 생성된 순서대로 더해 좌표 계산 후 떨어지는 속도

1/14
맵의 빈자리를 채우는 로직을 생각중.
1. 블럭을 파괴할때의 좌표 정보를 이용한다 
	1.1 블럭을 파괴하면서 해당 블럭 위의 블럭들에 내려와야하는 Y좌표 수를 저장하기
		블럭을 파괴할때에 파괴된 블럭 위에 접근, 해당 블럭의 변수에 or 해당 정보를 저장하는 2차원 배열에 값 입력 -> 블럭은 파괴 되는 경우도 있으니 배열로 하는것이 옳아보임.

		해당하는 값 만큼 블럭의 Y좌표 떨어뜨리고 목표 위치로 설정하여 블럭들 일괄적으로 애니메이션 재생. 

		우려사항.
		블럭을 파괴하는 함수로서 해당 작업을 수행하는것이 맞는가? (직관성 저하.) 
		이를 위해 블럭 컴포넌트에 접근해 얼마나 떨어지는지 받아와야한다. (접근하지 않고도 처리할 좋은 방법이 있나?) 		

2. 매치된 블럭을 전부 파괴 후 맵을 검사하여 처리한다
	2.1 맵 검사시 빈자리 위에 블럭이 존재한다면 하나씩 내리기 -> 빈자리 위에 블럭이 존재하지 않을 때 까지 반복
		맵을 검사하여 빈자리가 있음
		빈자리 위의 블럭들을 반복하여 접근 가장 낮은 빈자리로 하나씩 옮김
			없을경우 그냥 이동

		우려사항. 	
		반복과정이 너무 많아져 직관성이 떨어지지 않는가?
		다만, 브루트포스의 구조에 익지 않은 탓에 거부감 + 이해하기 어려움 이 있는것일 수도 있음. 
		연산 자체는 성능에 영향을 줄 만큼 많이 늘어나지는 않는 것 같긴 하다

	2.2 맵 검사시 빈자리 위에 블럭들에 내려와야하는 Y좌표 수를 저장하기
		맵을 검사하며 빈자리가 발견될 경우 빈자리 위에 존재하는 블럭의 변수에 or 
		해당 정보를 저장하는 2차원 배열에 값 입력
		해당하는 값 만큼 블럭의 Y좌표 떨어뜨리고 목표 위치로 설정하여 블럭들 일괄적으로 애니메이션 재생. 

		우려사항
		이미 블럭을 파괴할때에 순회한 맵을 이 작업을 위해 한번 더 순회해야한다.
		괜히 코드가 길어져 내용을 파악하기 힘들어지지는 않는가?

1/19
상태머신의 필요성을 느낌.
빈자리를 채우는 로직 결정.
블럭 파괴 시 list<vector2Int>에 좌표 저장 -> 해당 리스트에 저장된 좌표 위 블럭들에 얼마나 내려와야하는지 저장

1/22
(사담)chat gpt와 이 주제 관련의 대화를 하는것으로 집중력에 도움이 된다. 가벼운 마음으로 시작해서 관련된 이야기를 하다보면 자연스럽게 빠지는 느낌.
현재 마우스 메니저의 updata에서 부터 함수들이 실행되어 지나간다. 이것을 게임메니저로 옮길 계획.
-> 코드의 흐름이 훨씬 명확하고 직관적으로 보임. 마우스메니저 본연의 역할만을 가지게됨(모듈화).

1/27
상태 머신에 대해 오해가 있었다.
“나는 단순히 조건이 맞으면 해당 함수를 실행시키기” 로 생각했는데,
“상태 머신이 판단하여 필요한 함수를 불러오는 것” 이 정답에 조금 더 가까웠음.
예시로 지금 시점에 마우스 매니저가 가지고 있는 블럭을 선택할지, 스왑 시도인지 판단하는 코드는 상태 머신이 가지고 있는 것이 마우스 매니저와 게임 매니저 본연의 역할에 충실한 것.

때문에 기존의
 상태 변수의 값을 통해 필요한 함수 불러오기 
보다는
-> 마우스의 입력과 블럭의 애니메이션이 끝났는지를 게임매니저가 가진 정보를 통해 확인하고, 어떤 함수를 불러올지 정하기
가 조금 더 상태머신의 목적인 모듈화(유지보수 비용 감소, 코드의 직관성 증가)에 도움이 될 것.

먼저 마우스의 이벤트부터 수정 예정. 블럭 오브젝트를 클릭하면 보드상의 좌표를 전달하는 식으로.

1/28
마우스 구현 수정 완.
다음 수정해야 할 것은 MapManager.BlockSwap (함수명 변경 예정.)
상태 머신은 지금의 상태를 확인하고 제어할 수 있도록 하는 일종의 장치이다.
이것을 구현해 적용한다면 게임의 흐름을 상태 머신을 관리하는 게임 매니저에서 직선적으로 보일것이라 기대했는데, 잘못된 기대였다..
다만, 모듈화를 잘 해내어 게임매니저에서 게임 흐름을 관리한다면 비슷하게는 구현할 수 있을것.


FIX LATER
보드 좌표계의 직관성 (y, x 순서임. 보드의 구성과 생성, 좌표를 이용한 각종 기능들에 수정 필요.)
block의 x y 변수 -> Vector2dInt 로 변환